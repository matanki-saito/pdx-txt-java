/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.github.matanki_saito.rico;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import com.fasterxml.jackson.core.util.DefaultIndenter;
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.misc.Interval;
import org.antlr.v4.runtime.tree.ParseTree;
import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.matanki_saito.rico.antlr.PdxLexer;
import com.github.matanki_saito.rico.antlr.PdxParser;
import com.github.matanki_saito.rico.antlr.PdxParser.ArrayContext;
import com.github.matanki_saito.rico.antlr.PdxParser.ElementContext;
import com.github.matanki_saito.rico.antlr.PdxParser.KeyValueContext;
import com.github.matanki_saito.rico.antlr.PdxParser.PrimitiveContext;
import com.github.matanki_saito.rico.antlr.PdxParser.RootContext;
import com.github.matanki_saito.rico.exception.ArgumentException;
import com.github.matanki_saito.rico.exception.MachineException;
import com.github.matanki_saito.rico.exception.PdxParseException;
import com.github.matanki_saito.rico.exception.SystemException;
import com.github.matanki_saito.rico.exception.ThrowingErrorListener;

import lombok.experimental.UtilityClass;
import org.yaml.snakeyaml.Yaml;

/**
 * Paradox txt tool
 * <p>
 * ツール
 */
@UtilityClass
public class PdxTxtTool {
    private static final ObjectMapper objectMapper = new ObjectMapper();
    public static final String UTF8_BOM = "\uFEFF";

    /**
     * Validate txt
     *
     * @param txtFilePath path
     * @return %f:%l:%c: %m\n
     * @throws SystemException err
     */
    public static String validate(Path txtFilePath)
            throws SystemException {
        var charStream = charStreamUtil(txtFilePath);

        var context = generateContext(charStream);

        if (context.listener.getExceptions().isEmpty()) {
            return "";
        } else {
            return context
                    .listener
                    .getExceptions()
                    .stream()
                    .map(x->String.format("%s:%s:%s: %s",
                            Paths.get("").toAbsolutePath().relativize(txtFilePath.toAbsolutePath()),
                            x.line(),
                            x.charPositionInLine(),
                            x.message()))
                    .collect(Collectors.joining("\n"));
        }
    }

    public static void validateAllToSystemOut(Path root, Pattern matchPathPattern)
            throws SystemException {
        try {
            Files.walkFileTree(root, new SimpleFileVisitor<>() {
                @Override
                public FileVisitResult visitFile(Path filePath, BasicFileAttributes attrs) {
                    var pathStr = filePath.toAbsolutePath().toString();

                    var m = matchPathPattern.matcher(pathStr);
                    if (m.find()) {
                        try {
                            var result = validate(filePath);
                            if(!result.equals("")){
                                System.out.println(result);
                            }
                        } catch (SystemException e) {
                            throw new IllegalStateException(e);
                        }
                    }
                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            throw new MachineException("", e);
        }
    }

    /**
     * ParadoxTxtFormat to Json
     *
     * @param txtFile txt file path
     * @param pretty is pretty json
     *
     * @return Json
     *
     * @throws SystemException other system exception
     * @throws ArgumentException argument error
     */
    public static String convertTxtToJson(Path txtFile, boolean pretty)
            throws SystemException, ArgumentException {

        var charStream = charStreamUtil(txtFile);

        return innerConvertJson(charStream, pretty);
    }

    public static String convertTxtToJson(String txt, boolean pretty)
            throws ArgumentException, SystemException {
        CharStream charStream = CharStreams.fromString(txt);
        return innerConvertJson(charStream, pretty);
    }

    /**
     * Json to ParadoxTxtFormat
     *
     * @param jsonFile json file path
     *
     * @return ParadoxTxt
     *
     * @throws ArgumentException argument error
     */
    public static String convertJsonToTxt(Path jsonFile) throws ArgumentException {
        try {
            Object data = objectMapper.readValue(jsonFile.toFile(), Object.class);
            return decompile(data, 0);
        } catch (IOException e) {
            throw new ArgumentException("json error", e);
        }
    }

    /**
     * Json to ParadoxTxtFormat
     *
     * @param jsonString json string
     *
     * @return ParadoxTxt
     *
     * @throws ArgumentException argument errors
     */
    public static String convertJsonToTxt(String jsonString) throws ArgumentException {
        try {
            Object data = objectMapper.readValue(jsonString, Object.class);
            return decompile(data, 0);
        } catch (IOException e) {
            throw new ArgumentException("json error", e);
        }
    }

    private static String toJson(RootContext tree, boolean prettyPrint) throws SystemException {
        var map = compile(tree);
        try {
            return prettyPrint ? objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(map)
                               : objectMapper.writeValueAsString(map);
        } catch (JsonProcessingException e) {
            throw new SystemException("json exception", e);
        }
    }

    private static String decompile(Object data, int depth) {
        final int incrementedDepth = depth + 1;
        final String indent = StringUtils.repeat(" ", depth);

        if (data instanceof List<?> arrayList) {
            var joiningListText = arrayList.stream()
                                           .map(x -> indent + decompile(x, incrementedDepth))
                                           .collect(Collectors.joining("\n"));

            if (depth == 0) { // root
                return joiningListText;
            } else {
                return "{%n%s%n%s}".formatted(joiningListText, StringUtils.repeat(" ", depth - 2));
            }

        }

        if (data instanceof String string) {
            return string;
        }

        if (data instanceof Number number) {
            return number.toString();
        }

        if (data instanceof Map<?, ?> map) {
            var first = map
                    .entrySet()
                    .stream()
                    .findFirst();

            if (first.isPresent()) {
                var key = first.get().getKey().toString();
                var sKey = key.split("\\|");

                return "%s %s %s".formatted(
                        sKey.length > 1 ? sKey[0] : key,
                        sKey.length > 1 ? sKey[1] : "=",
                        decompile(first.get().getValue(), incrementedDepth)
                );
            }
        }

        throw new IllegalArgumentException();
    }

    private static Object compile(ParseTree tree) {
        if (tree instanceof RootContext rootContext) {
            return rootContext
                    .elements
                    .stream()
                    .map(PdxTxtTool::compile)
                    .collect(Collectors.toList());
        }

        if (tree instanceof ElementContext elementContext) {
            return compile(elementContext.getChild(0));
        }

        if (tree instanceof ArrayContext arrayContext) {
            return arrayContext
                    .elements
                    .stream()
                    .map(PdxTxtTool::compile)
                    .collect(Collectors.toList());
        }

        if (tree instanceof PrimitiveContext primitiveContext) {
            return primitiveContext.getChild(0).getText();
        }

        if (tree instanceof KeyValueContext keyValueContext) {
            var key = keyValueContext.key().getChild(0).toString();
            var operator = keyValueContext.nameSeparator().getChild(0).toString();
            return Map.of(
                    operator.equals("=") ? key : "%s|%s".formatted(key, operator),
                    compile(keyValueContext.value().getChild(0))
            );
        }

        return null;
    }

    public record TxtContext(PdxParser.RootContext tree, ThrowingErrorListener listener) { }

    private TxtContext generateContext(CharStream charStream){
        var listener = new ThrowingErrorListener();

        var lexer = new PdxLexer(charStream);
        lexer.removeErrorListeners();
        lexer.addErrorListener(listener);
        var tokens = new CommonTokenStream(lexer);
        var parser = new PdxParser(tokens);
        parser.removeErrorListeners();
        parser.addErrorListener(listener);

        return new TxtContext(parser.root(),listener);
    }
    private String innerConvertJson(CharStream charStream, boolean pretty)
            throws SystemException, ArgumentException {

        var context = generateContext(charStream);

        if (context.listener.getExceptions().isEmpty()) {
            return toJson(context.tree, pretty);
        } else {
            throw new PdxParseException("", context.listener.getExceptions());
        }
    }

    private CharStream charStreamUtil(Path path) throws MachineException{
        CharStream charStream;
        try {
            charStream = CharStreams.fromPath(path);
            var textHead = charStream.getText(Interval.of(0, 1));
            if (textHead.startsWith(UTF8_BOM)) {
                charStream.seek(1);
            }

            return charStream;
        } catch (IOException e) {
            throw new MachineException("IO exception", e);
        }
    }
}
